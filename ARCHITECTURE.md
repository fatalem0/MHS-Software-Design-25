# Архитектура CLI

## Состав команды

- Цыганов Иван
- Новокшанов Евгений
- Борисов Михаил
- Кудимов Дмитрий

## Представление команд

Команда после обработки представляет собой структуру данных
```rust
pub struct Command {
    pub name: String,           // имя команды
    pub args: Vec<String>,      // аргументы команды
    
    // поля для перенаправления потоков ввода/вывода
    pub stdin: Option<String>,      // содержимое для stdin или None
    pub stdout: Option<String>,     // файл для stdout или None
    pub append_stdout: bool,        // режим добавления для stdout
    pub stderr: Option<String>,     // файл для stderr или None  
    pub append_stderr: bool,        // режим добавления для stderr
}
```

## Встроенные команды

Проект содержит собственные реализации следующих команд:
- `echo` - вывод аргументов на stdout
- `cat` - вывод содержимого файлов или чтение из stdin
- `wc` - подсчет строк, слов и байт в файлах или stdin  
- `pwd` - вывод текущего рабочего каталога

Все команды компилируются как отдельные бинарные файлы в директории `target/release/`.
У команд `exit` и `help` своих исполняемых файлов нет - их простейшая логика выполняется прямо в read-execute-print-loop (repl). 

## Как создаются команды
Сырой пользовательский ввод проходит через многоэтапный конвейер обработки:

1. `InputProcessor.process()` получает строку от пользователя
2. `Tokenizer.tokenize()`**` разбивает строку на токены, учитывая кавычки и экранирование
3. `split_on_pipes_tokens()` делит токены по символу `|` для создания пайплайнов (на данный момент далее это не используется, т.к. пайпы все еще не поддерживаются)
4. Для каждой части пайплайна:
   - `QuoteHandler.handle()` обрабатывает и удаляет кавычки
   - `Expander.expand_tokens()` подставляет переменные окружения (поддерживает `$VAR` и `${VAR}`)
   - `produce_command()` анализирует перенаправления (`<`, `>`, `>>`, `2>`, `2>>`, `1>`, `1>>`) и формирует структуру Command

Результат: `Vec<Command>` готовых к исполнению команд с настроенными перенаправлениями.

## Как исполняются команды и работают перенаправления?

На данный момент реализация без пайплайнов выглядит так:

1. `REPL.run()` - главный цикл обработки пользовательского ввода
2. `InputProcessor.process()` возвращает `Vec<Command>` 
3. Для каждой команды последовательно:
   - REPL обрабатывает встроенные команды (`exit`, `help`)
   - Для stdin redirection (`< file`) - читает файл и передает содержимое как строку
   - `Runner.execute()` определяет тип исполнения:
     - Собственные бинарники: ищет в `bin_path` (например, `target/release/echo`)
     - Системные команды: запускает через системный PATH как fallback

4. Настройка перенаправлений в Runner:
   - `stdin`: передается как `Stdio::piped()` с записью данных в `child.stdin`
   - `stdout`: при наличии файла создается `File` и устанавливается `cmd.stdout(Stdio::from(file))`, поддерживает режимы overwrite/append
   - `stderr`: аналогично stdout, поддерживает режимы overwrite/append
   -  Выбор режимы открытия файлов: `create(true).write(true).truncate(true)` для `>` и `create(true).append(true)` для `>>`

5. Исполнение: каждая команда запускается в отдельном процессе через `std::process::Command`


## Как представляются переменные окружения

Переменные окружения управляются компонентом `Environment`:

```rust
pub struct Environment {
    vars: HashMap<String, String>
}

impl Environment {
    pub fn new() -> Self                        // пустое окружение
    pub fn with_vars(vars: HashMap<String, String>) -> Self  // из HashMap
    pub fn capture_current() -> Self            // захват системных переменных
    pub fn get(&self, key: &str) -> Option<&str>
    pub fn set<K, V>(&mut self, k: K, v: V) 
    pub fn remove(&mut self, k: &str)
}
```

## Где живет и как работает пайплайн
На данный момент мы разбираем строку по символам пайпа, но не поддерживаем запуск команд с помощью пайплайна. Они запустятся только последовательно.
TODO: поменять в следующей итерации

## Основные модули в архитектуре CLI

## Инициализация и главный цикл:
- `Init` - настройка путей к бинарникам и переменных окружения
- `Repl` - главный REPL (read-execute-print-loop) цикл, обработка пользовательского ввода

## Парсинг и обработка команд:
- `Tokenizer` - разбиение строки на токены с учетом кавычек и экранирования
- `QuoteHandler` - обработка одинарных `'` и двойных `"` кавычек  
- `Expander` - расширение переменных окружения (`$VAR`, `${VAR}`) с longest-match алгоритмом
- `InputProcessor` - координирует весь процесс парсинга, обрабатывает перенаправления и пайпы

## Исполнение:
- `Runner` - исполняет команды (собственные бинарники или системные команды)
- `Command` - структура данных для представления готовой к исполнению команды
- `Environment` - управление переменными окружения
